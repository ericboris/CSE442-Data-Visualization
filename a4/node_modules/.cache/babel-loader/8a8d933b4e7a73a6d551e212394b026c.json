{"ast":null,"code":"const introduction = {\n  title: 'Introduction',\n  body: `Since the Bitcoin whitepaper was first published in 2008, blockchains have exploded in popularity. But what are they, how do they work, and what are they used for? \n\nWhat are blockchains? Blockchains are publically accessible, append only, distributed databases. That is, they're databases that anyone can access and contribute to but that no one can alter the history of. \n\nWhat can blockchains be used for? Many people are familiar with blockchains through cryptocurrencies where blockchains are used to maintain a ledger of transactions where, transactions like Alice sends Bob 10$, Bob sends Cathy $4, and Cathy sends Alice $9 are bundled together as data into a block and that block is linked to other blocks to form a chain - a history of transactions. But blockchains are so much more than cryptocurrencies. They have applications as varied as securing digital voting, enforcing governance, proving ownership, managing supply chains, replacing corporate hierarchies, supporting the future of a decentralized web, and much more. \n\nBlockchain technology is still in its infancy, but nevertheless represents the possiblity of developing a more egalitarian world of trustless, permissionless, peer-to-peer cooperation.\n\nThat sounds good and well, but how do blockchains work? That's a huge topic and one we can't cover completely here, but we'll do our best to cover the basics.`\n};\nconst hash = {\n  title: 'Hash',\n  body: `Before we can talk about blockchains, we have to understand what a hash function is since hashing serves as the cryptographic foundation upon which blockchains function. Simply put, a hash is like a fingerprint - it uniquely identifies some data. More precisely, a hash function is a deterministic, one-way mathematical function that maps arbitrarily sized inputs to fixed sized outputs.\n\nYikes! Let's explain those terms.\n\nHashing is one way because it's fast and easy to compute the hash of some data, but it's practically impossible to figure out the data that produced a given hash. Hashing produces fixed sized outputs from arbitrary sized inputs. I.e. regardless of the amount of data that goes into a hash function, the resulting hash length will always be the same. And hashing is deterministic, the same data always produces the same hash.\n\nIn short, hashing privides easily identifiable, and impossible to reverse-engineer, fingerprints of data.`\n};\nconst block = {\n  title: 'Block',\n  body: `We now turn to the basic building block of any blockchain - a block. You'll see that it's similar to the last example except that there are a few additions. \n\nAs before, changes to the data field affect the hash, now however, changes to the block number and nonce fields also affect the hash. You'll notice that changing any of the values changes the block's color - from green to red. This is how we indicate whether the block is signed. \n\nSo what is a signed block? A signed block is a valid block, one in which any transactions are considered to be valid. That is, computational work has been done to verify that a block contains valid transactional data and has the hash to prove it. This signed hash, which verifies that the block is signed, is one with a certain number of leading zeros. In the interest of computational time, we've chosen to use 4 zeros as our target for determining when a block is signed. \n\nComputational time? Yes. We have to do work to find a signed block and that's where mining comes in. Mining is the work done to find a nonce which, when concatenated with the block's other fields, results in a signed block. Because of the unpredictability of the hash algorithm, there is no efficient algorithm for finding this nonce, so mining is essentially the process of guessing nonces until a signed hash is found. \n\nTo see this in action, change some fields in the block, turn on visualize, and click Mine! It could take some time, actually - it could take a long time, but eventually a nonce with be found and the block signed. Try it out!\n\nHint: Turn off visualize if you want the block to be mined faster. \n\nMining, or computational work, is used (in some but not all) blockchains to prevent denial of service attacks and spam against the network and as a mechanism for reaching consensus and for adding new blocks to the chain. In the specific use of cryptocurrency blockchains like Bitcoin, mining is also how new Bitcoins are created, it's the financial reward for performing computational work.`\n};\nconst blockchain = {\n  title: 'Blockchain',\n  body: `We're finally ready to talk about blockchains.\n\nI addition to having multiple blocks, you'll see that each block now has an added \"previous hash\" field which is the hash of the previous block. The current block stores and uses the previous block's hash when computing it's own hash. And that's a blockchain!\n\nBut so what? Why does referencing the previous block's hash matter? Well, for one, this linking is what turns disparate blocks into a blockchain. More significantly though, this makes blockchains tamper-proof since changes to one block require re-mining every following block.\n\nThis gives us an unalterable history of transactional data which is really nice to have in a distributed database.`\n};\nconst distributed = {\n  title: 'Distributed',\n  body: `As we've described, blockchains are a great at resisting alterations to their history, but what's to stop someone from presenting a signed hash and claiming to have mined a block from adding an otherwise invalid block to the chain? That's where consensus comes in. \n\nBut what is consensus? That's actually quite simple, the consensus hash is the most widely agreed upon hash for the last block in the network. So, if 51% or more of the peers in the network agree on the hash for the current block, consensus is reached and their chains are considered valid. Any chains with hashes not agreeing with the consensus are consisidered invalid.\n\nWe illustrate this by using a green background behind a chain when that chain agrees with the consensus, and red otherwise. \n\nUsing consensus in this way prevents introducing, not only invalid current blocks - since, even though the block may be signed, it's hash won't agree with the consensus - but also prevents tampering with the history of the chain since an entirely re-mined chain's hash won't agree with the consensus either.\n\nYou can see this in our example by trying to alter any one chain's fields and re-mining the blocks. No matter how hard you try, you can't get a blockchain with different fields to match the other chains!`\n};\nconst conclusion = {\n  title: 'Conclusion',\n  body: `THIS IS THE CONCLUSION BODY`\n};\nexport { introduction, hash, block, blockchain, distributed, conclusion };","map":{"version":3,"sources":["/Users/ericboris/Developer/CSE442/a4/src/descriptions/descriptions.js"],"names":["introduction","title","body","hash","block","blockchain","distributed","conclusion"],"mappings":"AAAA,MAAMA,YAAY,GAAG;AACjBC,EAAAA,KAAK,EAAE,cADU;AAEjBC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXqB,CAArB;AAcA,MAAMC,IAAI,GAAG;AACTF,EAAAA,KAAK,EAAE,MADE;AAETC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AATa,CAAb;AAYA,MAAME,KAAK,GAAG;AACVH,EAAAA,KAAK,EAAE,OADG;AAEVC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfc,CAAd;AAkBA,MAAMG,UAAU,GAAG;AACfJ,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AATmB,CAAnB;AAYA,MAAMI,WAAW,GAAG;AAChBL,EAAAA,KAAK,EAAE,aADS;AAEhBC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXoB,CAApB;AAcA,MAAMK,UAAU,GAAG;AACfN,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EAAG;AAFQ,CAAnB;AAKA,SAASF,YAAT,EAAuBG,IAAvB,EAA6BC,KAA7B,EAAoCC,UAApC,EAAgDC,WAAhD,EAA6DC,UAA7D","sourcesContent":["const introduction = {\n    title: 'Introduction',\n    body: \n`Since the Bitcoin whitepaper was first published in 2008, blockchains have exploded in popularity. But what are they, how do they work, and what are they used for? \n\nWhat are blockchains? Blockchains are publically accessible, append only, distributed databases. That is, they're databases that anyone can access and contribute to but that no one can alter the history of. \n\nWhat can blockchains be used for? Many people are familiar with blockchains through cryptocurrencies where blockchains are used to maintain a ledger of transactions where, transactions like Alice sends Bob 10$, Bob sends Cathy $4, and Cathy sends Alice $9 are bundled together as data into a block and that block is linked to other blocks to form a chain - a history of transactions. But blockchains are so much more than cryptocurrencies. They have applications as varied as securing digital voting, enforcing governance, proving ownership, managing supply chains, replacing corporate hierarchies, supporting the future of a decentralized web, and much more. \n\nBlockchain technology is still in its infancy, but nevertheless represents the possiblity of developing a more egalitarian world of trustless, permissionless, peer-to-peer cooperation.\n\nThat sounds good and well, but how do blockchains work? That's a huge topic and one we can't cover completely here, but we'll do our best to cover the basics.`\n};\n\nconst hash = {\n    title: 'Hash',\n    body:\n`Before we can talk about blockchains, we have to understand what a hash function is since hashing serves as the cryptographic foundation upon which blockchains function. Simply put, a hash is like a fingerprint - it uniquely identifies some data. More precisely, a hash function is a deterministic, one-way mathematical function that maps arbitrarily sized inputs to fixed sized outputs.\n\nYikes! Let's explain those terms.\n\nHashing is one way because it's fast and easy to compute the hash of some data, but it's practically impossible to figure out the data that produced a given hash. Hashing produces fixed sized outputs from arbitrary sized inputs. I.e. regardless of the amount of data that goes into a hash function, the resulting hash length will always be the same. And hashing is deterministic, the same data always produces the same hash.\n\nIn short, hashing privides easily identifiable, and impossible to reverse-engineer, fingerprints of data.`\n};\n\nconst block = {\n    title: 'Block',\n    body:\n`We now turn to the basic building block of any blockchain - a block. You'll see that it's similar to the last example except that there are a few additions. \n\nAs before, changes to the data field affect the hash, now however, changes to the block number and nonce fields also affect the hash. You'll notice that changing any of the values changes the block's color - from green to red. This is how we indicate whether the block is signed. \n\nSo what is a signed block? A signed block is a valid block, one in which any transactions are considered to be valid. That is, computational work has been done to verify that a block contains valid transactional data and has the hash to prove it. This signed hash, which verifies that the block is signed, is one with a certain number of leading zeros. In the interest of computational time, we've chosen to use 4 zeros as our target for determining when a block is signed. \n\nComputational time? Yes. We have to do work to find a signed block and that's where mining comes in. Mining is the work done to find a nonce which, when concatenated with the block's other fields, results in a signed block. Because of the unpredictability of the hash algorithm, there is no efficient algorithm for finding this nonce, so mining is essentially the process of guessing nonces until a signed hash is found. \n\nTo see this in action, change some fields in the block, turn on visualize, and click Mine! It could take some time, actually - it could take a long time, but eventually a nonce with be found and the block signed. Try it out!\n\nHint: Turn off visualize if you want the block to be mined faster. \n\nMining, or computational work, is used (in some but not all) blockchains to prevent denial of service attacks and spam against the network and as a mechanism for reaching consensus and for adding new blocks to the chain. In the specific use of cryptocurrency blockchains like Bitcoin, mining is also how new Bitcoins are created, it's the financial reward for performing computational work.`\n};\n\nconst blockchain = {\n    title: 'Blockchain',\n    body:\n`We're finally ready to talk about blockchains.\n\nI addition to having multiple blocks, you'll see that each block now has an added \"previous hash\" field which is the hash of the previous block. The current block stores and uses the previous block's hash when computing it's own hash. And that's a blockchain!\n\nBut so what? Why does referencing the previous block's hash matter? Well, for one, this linking is what turns disparate blocks into a blockchain. More significantly though, this makes blockchains tamper-proof since changes to one block require re-mining every following block.\n\nThis gives us an unalterable history of transactional data which is really nice to have in a distributed database.`\n};\n\nconst distributed = {\n    title: 'Distributed',\n    body: \n`As we've described, blockchains are a great at resisting alterations to their history, but what's to stop someone from presenting a signed hash and claiming to have mined a block from adding an otherwise invalid block to the chain? That's where consensus comes in. \n\nBut what is consensus? That's actually quite simple, the consensus hash is the most widely agreed upon hash for the last block in the network. So, if 51% or more of the peers in the network agree on the hash for the current block, consensus is reached and their chains are considered valid. Any chains with hashes not agreeing with the consensus are consisidered invalid.\n\nWe illustrate this by using a green background behind a chain when that chain agrees with the consensus, and red otherwise. \n\nUsing consensus in this way prevents introducing, not only invalid current blocks - since, even though the block may be signed, it's hash won't agree with the consensus - but also prevents tampering with the history of the chain since an entirely re-mined chain's hash won't agree with the consensus either.\n\nYou can see this in our example by trying to alter any one chain's fields and re-mining the blocks. No matter how hard you try, you can't get a blockchain with different fields to match the other chains!`\n}\n\nconst conclusion = {\n    title: 'Conclusion',\n    body: `THIS IS THE CONCLUSION BODY`\n}\n\nexport { introduction, hash, block, blockchain, distributed, conclusion }\n"]},"metadata":{},"sourceType":"module"}