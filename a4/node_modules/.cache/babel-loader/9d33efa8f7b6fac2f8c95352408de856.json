{"ast":null,"code":"const hash = {\n  title: 'Hash',\n  body: `Before we can discuss blockchains we have to understand what a hash function is. A hash function is a determinisic, one-way mathematical function that maps arbitrarily sized data (input) to a fixed size bit array (output).\n                                                                                  \n        There are three key features here.                                      \n        1. One-Way. It's functionally impossible, even knowing the output, to reverse engineer the input. \n        2. Arbitrary sized input to fixed size output. Whether the input is an empty string or the text every book ever written, the output array will be the same size. In this case, using SHA256, the output will be 256 bits long.\n        3. Deterministic. The same input always produces the same output.       \n                                                                                  \n        On a blockchain, like Bitcoin for example, hashing is used to verify that a certain amount of computation work has been conducted.`\n};\nconst block = {\n  title: 'Block',\n  body: `We now have the basic building block of a blockchain - a block. It's similar to the previous hash except there's an added Nonce field and a Mine button. \n                                                                                  \n        We can still change any of the fields as we like and the hash will change since the hash is computed using a combination of the Block, Nonce, and Data fields. However, the block won't be signed. \n                                                                                  \n        What's a signed block? A signed block, in this case, is one where the hash that starts with 4 leading zeros.\n                                                                                \n        That's where mining comes in. Mining is the task of finding a nonce such that when it's hashed with block number and data the hash starts with 4 zeros. When such a nonce is found and the hash starts with 4 zeros we say that block is signed. \n                                                                                \n        Note, the choice of 4 leading zeros is arbitrary and is used here for demonstration purposes only. The point is that finding a nonce that satisfies a hash constraint takes is computationally effortful. \n                                                                                  \n        The significance of mining a block is that it takes time to do but any attempts to change the state of a mined block can be instantly identified making it computationally expensive to change.\n                                                                                \n        Play with the block component to get a feel for how any changes affect the hash and how mining changes the hash and the nonce.`\n};\nconst blockchain = {\n  title: 'Blockchain',\n  body: `Now we're ready to talk about a blockchain.                              \n                                                                                  \n        I addition to having multiple blocks now, you'll notice that we've added a \"previous hash\" field which references the hash of the previous block. \n                                                                                  \n        Suppose all the blocks are signed, but now we want to alter some field in the middle block, you'll see that doing so not only breaks the block with the changed field, it breaks every block in the \nchain as well! So by incorporating the previous block's hash in the computation for the following block we've connected each block in a chain. \n                                                                                \n        This is important because if we wanted to manipulate the history of the blockchain we have to re-mine, not only the altered block but every block that follows which makes the blockchain tamper resistant and, in fact, more resistant to change the further back we go. This is one of the features that makes blockchains so important, anyone can access it but no one can reasonably edit it's history.`\n};\nexport { hash, block, blockchain };","map":{"version":3,"sources":["/Users/ericboris/Developer/CSE442/a4/src/descriptions/descriptions.js"],"names":["hash","title","body","block","blockchain"],"mappings":"AAAA,MAAMA,IAAI,GAAG;AACTC,EAAAA,KAAK,EAAE,MADE;AAETC,EAAAA,IAAI,EACC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AAVa,CAAb;AAaA,MAAMC,KAAK,GAAG;AACVF,EAAAA,KAAK,EAAE,OADG;AAEVC,EAAAA,IAAI,EACC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfc,CAAd;AAkBA,MAAME,UAAU,GAAG;AACfH,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EACC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AAVmB,CAAnB;AAaA,SAASF,IAAT,EAAeG,KAAf,EAAsBC,UAAtB","sourcesContent":["const hash = {                                                         \n    title: 'Hash',                                                                \n    body:                                                                         \n        `Before we can discuss blockchains we have to understand what a hash function is. A hash function is a determinisic, one-way mathematical function that maps arbitrarily sized data (input) to a fixed size bit array (output).\n                                                                                  \n        There are three key features here.                                      \n        1. One-Way. It's functionally impossible, even knowing the output, to reverse engineer the input. \n        2. Arbitrary sized input to fixed size output. Whether the input is an empty string or the text every book ever written, the output array will be the same size. In this case, using SHA256, the output will be 256 bits long.\n        3. Deterministic. The same input always produces the same output.       \n                                                                                  \n        On a blockchain, like Bitcoin for example, hashing is used to verify that a certain amount of computation work has been conducted.`\n};  \n\nconst block = {                                                        \n    title: 'Block',                                                               \n    body:                                                                         \n        `We now have the basic building block of a blockchain - a block. It's similar to the previous hash except there's an added Nonce field and a Mine button. \n                                                                                  \n        We can still change any of the fields as we like and the hash will change since the hash is computed using a combination of the Block, Nonce, and Data fields. However, the block won't be signed. \n                                                                                  \n        What's a signed block? A signed block, in this case, is one where the hash that starts with 4 leading zeros.\n                                                                                \n        That's where mining comes in. Mining is the task of finding a nonce such that when it's hashed with block number and data the hash starts with 4 zeros. When such a nonce is found and the hash starts with 4 zeros we say that block is signed. \n                                                                                \n        Note, the choice of 4 leading zeros is arbitrary and is used here for demonstration purposes only. The point is that finding a nonce that satisfies a hash constraint takes is computationally effortful. \n                                                                                  \n        The significance of mining a block is that it takes time to do but any attempts to change the state of a mined block can be instantly identified making it computationally expensive to change.\n                                                                                \n        Play with the block component to get a feel for how any changes affect the hash and how mining changes the hash and the nonce.`\n};    \n\nconst blockchain = {                                                             \n    title: 'Blockchain',                                                          \n    body:                                                                         \n        `Now we're ready to talk about a blockchain.                              \n                                                                                  \n        I addition to having multiple blocks now, you'll notice that we've added a \"previous hash\" field which references the hash of the previous block. \n                                                                                  \n        Suppose all the blocks are signed, but now we want to alter some field in the middle block, you'll see that doing so not only breaks the block with the changed field, it breaks every block in the \nchain as well! So by incorporating the previous block's hash in the computation for the following block we've connected each block in a chain. \n                                                                                \n        This is important because if we wanted to manipulate the history of the blockchain we have to re-mine, not only the altered block but every block that follows which makes the blockchain tamper resistant and, in fact, more resistant to change the further back we go. This is one of the features that makes blockchains so important, anyone can access it but no one can reasonably edit it's history.`\n};                                                                                \n              \nexport { hash, block, blockchain }\n"]},"metadata":{},"sourceType":"module"}