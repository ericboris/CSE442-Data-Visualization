{"ast":null,"code":"const hash = {\n  title: 'Hash',\n  body: `Before we can talk about blockchains, we have to understand what a hash function is since hashing serves as the cryptographic foundation upon which blockchains function. Simply put, a hash is like a fingerprint - it uniquely identifies some data. More precisely, a hash function is a deterministic, one-way mathematical function that maps arbitrarily sized inputs to fixed sized outputs.\n\nYikes! Let's explain those terms.\n\nHashing is one way because it's fast and easy to compute the hash of some data, but it's practically impossible to figure out the data that produced a given hash. Hashing produces fixed sized outputs from arbitrary sized inputs. I.e. regardless of the amount of data that goes into a hash function, the resulting hash length will always be the same. And hashing is deterministic, the same data always produces the same hash.\n\nIn short, hashing privides easily identifiable, and impossible to reverse-engineer, fingerprints of data.`\n};\nconst block = {\n  title: 'Block',\n  body: `We now turn to the basic building block of any blockchain - a block. You'll see that it's similar to the last example except that there are a few additions. \n\nAs before, changes to the data field affect the hash, now however, changes to the block number and nonce fields also affect the hash. You'll notice that changing any of the values changes the block's color - from green to red. This is how we indicate whether the block is signed. \n\nSo what is a signed block? A signed block is a valid block, one in which any transactions are considered to be valid. That is, computational work has been done to verify that a block contains valid transactional data and has the hash to prove it. This signed hash, which verifies that the block is signed, is one with a certain number of leading zeros. In the interest of computational time, we've chosen to use 4 zeros as our target for determining when a block is signed. \n\nComputational time? Yes. We have to do work to find a signed block and that's where mining comes in. Mining is the work done to find a nonce which, when concatenated with the block's other fields, results in a signed block. Because of the unpredictability of the hash algorithm, there is no efficient algorithm for finding this nonce, so mining is essentially the process of guessing nonces until a signed hash is found. \n\nTo see this in action, change some fields in the block, turn on visualize, and click Mine! It could take some time, actually - it could take a long time, but eventually a nonce with be found and the block signed. Try it out!\n\nHint: Turn off visualize if you want the block to be mined faster. \n\nMining, or computational work, is used (in some but not all) blockchains to prevent denial of service attacks and spam against the network and as a mechanism for reaching consensus and for adding new blocks to the chain. In the specific use of cryptocurrency blockchains like Bitcoin, mining is also how new Bitcoins are created, it's the financial reward for performing computational work.`\n};\nconst blockchain = {\n  title: 'Blockchain',\n  body: `We're finally ready to talk about blockchains.\n\nI addition to having multiple blocks, you'll see that each block now has an added \"previous hash\" field which is the hash of the previous block. The current block stores and uses the previous block's hash when computing it's own hash. And that's a blockchain!\n\nBut so what? Why does referencing the previous block's hash matter? Well, for one, this linking is what turns disparate blocks into a blockchain. More significantly though, this makes blockchains tamper proof since changes to one block require re-mining every following block.\n\nthis makes it hard to tamper with the history of the blockchain since changing any block in the chain requries re-mining that block and every block after it. In other words, it's nearly impossible to alter the history of a blockchain since re-mining blocks is prohibitively expensive. \n\nSuppose all the blocks are signed, but now we want to alter some field in the middle block, you'll see that doing so not only breaks the block with the changed field, it breaks every block in the\nchain as well! So by incorporating the previous block's hash in the computation for the following block we've connected each block in a chain.\n\nThis is important because if we wanted to manipulate the history of the blockchain we have to re-mine, not only the altered block but every block that follows which makes the blockchain tamper resistant and, in fact, more resistant to change the further back we go. This is one of the features that makes blockchains so important, anyone can access it but no one can reasonably edit it's history.`\n};\nconst distributed = {\n  title: 'Distributed',\n  body: ``\n};\nconst conclusion = {\n  title: 'Conclusion',\n  body: `THIS IS THE CONCLUSION BODY`\n};\nexport { hash, block, blockchain, distributed, conclusion };","map":{"version":3,"sources":["/Users/ericboris/Developer/CSE442/a4/src/descriptions/descriptions.js"],"names":["hash","title","body","block","blockchain","distributed","conclusion"],"mappings":"AAAA,MAAMA,IAAI,GAAG;AACTC,EAAAA,KAAK,EAAE,MADE;AAETC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AATa,CAAb;AAYA,MAAMC,KAAK,GAAG;AACVF,EAAAA,KAAK,EAAE,OADG;AAEVC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfc,CAAd;AAkBA,MAAME,UAAU,GAAG;AACfH,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdmB,CAAnB;AAiBA,MAAMG,WAAW,GAAG;AAChBJ,EAAAA,KAAK,EAAE,aADS;AAEhBC,EAAAA,IAAI,EAAG;AAFS,CAApB;AAKA,MAAMI,UAAU,GAAG;AACfL,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EAAG;AAFQ,CAAnB;AAKA,SAASF,IAAT,EAAeG,KAAf,EAAsBC,UAAtB,EAAkCC,WAAlC,EAA+CC,UAA/C","sourcesContent":["const hash = {\n    title: 'Hash',\n    body:\n`Before we can talk about blockchains, we have to understand what a hash function is since hashing serves as the cryptographic foundation upon which blockchains function. Simply put, a hash is like a fingerprint - it uniquely identifies some data. More precisely, a hash function is a deterministic, one-way mathematical function that maps arbitrarily sized inputs to fixed sized outputs.\n\nYikes! Let's explain those terms.\n\nHashing is one way because it's fast and easy to compute the hash of some data, but it's practically impossible to figure out the data that produced a given hash. Hashing produces fixed sized outputs from arbitrary sized inputs. I.e. regardless of the amount of data that goes into a hash function, the resulting hash length will always be the same. And hashing is deterministic, the same data always produces the same hash.\n\nIn short, hashing privides easily identifiable, and impossible to reverse-engineer, fingerprints of data.`\n};\n\nconst block = {\n    title: 'Block',\n    body:\n`We now turn to the basic building block of any blockchain - a block. You'll see that it's similar to the last example except that there are a few additions. \n\nAs before, changes to the data field affect the hash, now however, changes to the block number and nonce fields also affect the hash. You'll notice that changing any of the values changes the block's color - from green to red. This is how we indicate whether the block is signed. \n\nSo what is a signed block? A signed block is a valid block, one in which any transactions are considered to be valid. That is, computational work has been done to verify that a block contains valid transactional data and has the hash to prove it. This signed hash, which verifies that the block is signed, is one with a certain number of leading zeros. In the interest of computational time, we've chosen to use 4 zeros as our target for determining when a block is signed. \n\nComputational time? Yes. We have to do work to find a signed block and that's where mining comes in. Mining is the work done to find a nonce which, when concatenated with the block's other fields, results in a signed block. Because of the unpredictability of the hash algorithm, there is no efficient algorithm for finding this nonce, so mining is essentially the process of guessing nonces until a signed hash is found. \n\nTo see this in action, change some fields in the block, turn on visualize, and click Mine! It could take some time, actually - it could take a long time, but eventually a nonce with be found and the block signed. Try it out!\n\nHint: Turn off visualize if you want the block to be mined faster. \n\nMining, or computational work, is used (in some but not all) blockchains to prevent denial of service attacks and spam against the network and as a mechanism for reaching consensus and for adding new blocks to the chain. In the specific use of cryptocurrency blockchains like Bitcoin, mining is also how new Bitcoins are created, it's the financial reward for performing computational work.`\n};\n\nconst blockchain = {\n    title: 'Blockchain',\n    body:\n`We're finally ready to talk about blockchains.\n\nI addition to having multiple blocks, you'll see that each block now has an added \"previous hash\" field which is the hash of the previous block. The current block stores and uses the previous block's hash when computing it's own hash. And that's a blockchain!\n\nBut so what? Why does referencing the previous block's hash matter? Well, for one, this linking is what turns disparate blocks into a blockchain. More significantly though, this makes blockchains tamper proof since changes to one block require re-mining every following block.\n\nthis makes it hard to tamper with the history of the blockchain since changing any block in the chain requries re-mining that block and every block after it. In other words, it's nearly impossible to alter the history of a blockchain since re-mining blocks is prohibitively expensive. \n\nSuppose all the blocks are signed, but now we want to alter some field in the middle block, you'll see that doing so not only breaks the block with the changed field, it breaks every block in the\nchain as well! So by incorporating the previous block's hash in the computation for the following block we've connected each block in a chain.\n\nThis is important because if we wanted to manipulate the history of the blockchain we have to re-mine, not only the altered block but every block that follows which makes the blockchain tamper resistant and, in fact, more resistant to change the further back we go. This is one of the features that makes blockchains so important, anyone can access it but no one can reasonably edit it's history.`\n};\n\nconst distributed = {\n    title: 'Distributed',\n    body: ``\n}\n\nconst conclusion = {\n    title: 'Conclusion',\n    body: `THIS IS THE CONCLUSION BODY`\n}\n\nexport { hash, block, blockchain, distributed, conclusion }\n"]},"metadata":{},"sourceType":"module"}