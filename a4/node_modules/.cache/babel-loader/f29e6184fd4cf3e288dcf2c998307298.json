{"ast":null,"code":"const hash = {\n  title: 'Hash',\n  body: `Before we can talk about blockchains, we have to understand what a hash function is since hashing serves as the cryptographic foundation upon which blockchains function. Simply put, a hash is like a fingerprint - it uniquely identifies some data. More precisely, a hash function is a deterministic, one-way mathematical function that maps arbitrarily sized inputs to fixed sized outputs.\n\nYikes! Let's explain those terms.\n\nHashing is one way because it's fast and easy to compute the hash of some data, but it's practically impossible to figure out the data that produced a given hash. Hashing produces fixed sized outputs from arbitrary sized inputs. I.e. regardless of the amount of data that goes into a hash function, the resulting hash length will always be the same. And hashing is deterministic, the same data always produces the same hash.\n\nIn short, hashing privides easily identifiable, and impossible to reverse-engineer, fingerprints of data.`\n};\nconst block = {\n  title: 'Block',\n  body: `We now turn to the basic building block of any blockchain - a block. You'll see that it's similar to the last example except that there are a few additions. \n\nAs before, changes to the data field affect the hash, now however, changes to the block number and nonce fields also affect the hash. You'll notice that changing any of the values changes the block's color - from green to red. This is how we indicate whether the block is signed. \n\nSo what is a signed block? A signed block is a valid block, one in which any transactions are considered to be valid. That is, computational work has been done to verify that a block contains valid transactional data and has the hash to prove it. This signed hash, which verifies that the block is signed, is one with a certain number of leading zeros. In the interest of computational time, we've chosen to use 4 zeros as our target for determining when a block is signed. \n\nComputational time? Yes. We have to do work to find a signed block and that's where mining comes in. Mining is the work done to find a nonce which, when concatenated with the block's other fields, results in a signed block. Because of the unpredictability of the hash algorithm, there is no efficient algorithm for finding this nonce, so mining is essentially the process of guessing nonces until a signed hash is found. \n\nTo see this in action, change some fields in the block, turn on visualize, and click Mine! It could take some time, actually - it could take a long time, but eventually a nonce with be found and the block signed. Try it out!\n\nHint: Turn off visualize if you want the block to be mined faster. \n\nMining, or computational work, is used (in some but not all) blockchains to prevent denial of service attacks and spam against the network and as a mechanism for reaching consensus and for adding new blocks to the chain. In the specific use of cryptocurrency blockchains like Bitcoin, mining is also how new Bitcoins are created, it's the financial reward for performing computational work.`\n};\nconst blockchain = {\n  title: 'Blockchain',\n  body: `We're finally ready to talk about blockchains.\n\nI addition to having multiple blocks, you'll see that each block now has an added \"previous hash\" field which is the hash of the previous block. The current block stores and uses the previous block's hash when computing it's own hash. And that's a blockchain!\n\nBut so what? Why does referencing the previous block's hash matter? Well, for one, this linking is what turns disparate blocks into a blockchain. More significantly though, this makes blockchains tamper-proof since changes to one block require re-mining every following block.\n\nThis gives us an unalterable history of transactional data which is really nice to have in a distributed database.`\n};\nconst distributed = {\n  title: 'Distributed',\n  body: `As we've described, blockchains are a great at resisting alterations to their history, but what's to stop someone from presenting a signed hash and claiming to have mined a block from adding an otherwise invalid block to the chain? That's where consensus comes in. \n\nTo illustrate this, we add a couple more blockchains from our previous example and we say that chains on a green background agree with the consensus and chains on a red background don't.\n    \n`\n};\nconst conclusion = {\n  title: 'Conclusion',\n  body: `THIS IS THE CONCLUSION BODY`\n};\nexport { hash, block, blockchain, distributed, conclusion };","map":{"version":3,"sources":["/Users/ericboris/Developer/CSE442/a4/src/descriptions/descriptions.js"],"names":["hash","title","body","block","blockchain","distributed","conclusion"],"mappings":"AAAA,MAAMA,IAAI,GAAG;AACTC,EAAAA,KAAK,EAAE,MADE;AAETC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AATa,CAAb;AAYA,MAAMC,KAAK,GAAG;AACVF,EAAAA,KAAK,EAAE,OADG;AAEVC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfc,CAAd;AAkBA,MAAME,UAAU,GAAG;AACfH,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AATmB,CAAnB;AAYA,MAAMG,WAAW,GAAG;AAChBJ,EAAAA,KAAK,EAAE,aADS;AAEhBC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AAPoB,CAApB;AAUA,MAAMI,UAAU,GAAG;AACfL,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EAAG;AAFQ,CAAnB;AAKA,SAASF,IAAT,EAAeG,KAAf,EAAsBC,UAAtB,EAAkCC,WAAlC,EAA+CC,UAA/C","sourcesContent":["const hash = {\n    title: 'Hash',\n    body:\n`Before we can talk about blockchains, we have to understand what a hash function is since hashing serves as the cryptographic foundation upon which blockchains function. Simply put, a hash is like a fingerprint - it uniquely identifies some data. More precisely, a hash function is a deterministic, one-way mathematical function that maps arbitrarily sized inputs to fixed sized outputs.\n\nYikes! Let's explain those terms.\n\nHashing is one way because it's fast and easy to compute the hash of some data, but it's practically impossible to figure out the data that produced a given hash. Hashing produces fixed sized outputs from arbitrary sized inputs. I.e. regardless of the amount of data that goes into a hash function, the resulting hash length will always be the same. And hashing is deterministic, the same data always produces the same hash.\n\nIn short, hashing privides easily identifiable, and impossible to reverse-engineer, fingerprints of data.`\n};\n\nconst block = {\n    title: 'Block',\n    body:\n`We now turn to the basic building block of any blockchain - a block. You'll see that it's similar to the last example except that there are a few additions. \n\nAs before, changes to the data field affect the hash, now however, changes to the block number and nonce fields also affect the hash. You'll notice that changing any of the values changes the block's color - from green to red. This is how we indicate whether the block is signed. \n\nSo what is a signed block? A signed block is a valid block, one in which any transactions are considered to be valid. That is, computational work has been done to verify that a block contains valid transactional data and has the hash to prove it. This signed hash, which verifies that the block is signed, is one with a certain number of leading zeros. In the interest of computational time, we've chosen to use 4 zeros as our target for determining when a block is signed. \n\nComputational time? Yes. We have to do work to find a signed block and that's where mining comes in. Mining is the work done to find a nonce which, when concatenated with the block's other fields, results in a signed block. Because of the unpredictability of the hash algorithm, there is no efficient algorithm for finding this nonce, so mining is essentially the process of guessing nonces until a signed hash is found. \n\nTo see this in action, change some fields in the block, turn on visualize, and click Mine! It could take some time, actually - it could take a long time, but eventually a nonce with be found and the block signed. Try it out!\n\nHint: Turn off visualize if you want the block to be mined faster. \n\nMining, or computational work, is used (in some but not all) blockchains to prevent denial of service attacks and spam against the network and as a mechanism for reaching consensus and for adding new blocks to the chain. In the specific use of cryptocurrency blockchains like Bitcoin, mining is also how new Bitcoins are created, it's the financial reward for performing computational work.`\n};\n\nconst blockchain = {\n    title: 'Blockchain',\n    body:\n`We're finally ready to talk about blockchains.\n\nI addition to having multiple blocks, you'll see that each block now has an added \"previous hash\" field which is the hash of the previous block. The current block stores and uses the previous block's hash when computing it's own hash. And that's a blockchain!\n\nBut so what? Why does referencing the previous block's hash matter? Well, for one, this linking is what turns disparate blocks into a blockchain. More significantly though, this makes blockchains tamper-proof since changes to one block require re-mining every following block.\n\nThis gives us an unalterable history of transactional data which is really nice to have in a distributed database.`\n};\n\nconst distributed = {\n    title: 'Distributed',\n    body: \n`As we've described, blockchains are a great at resisting alterations to their history, but what's to stop someone from presenting a signed hash and claiming to have mined a block from adding an otherwise invalid block to the chain? That's where consensus comes in. \n\nTo illustrate this, we add a couple more blockchains from our previous example and we say that chains on a green background agree with the consensus and chains on a red background don't.\n    \n`\n}\n\nconst conclusion = {\n    title: 'Conclusion',\n    body: `THIS IS THE CONCLUSION BODY`\n}\n\nexport { hash, block, blockchain, distributed, conclusion }\n"]},"metadata":{},"sourceType":"module"}