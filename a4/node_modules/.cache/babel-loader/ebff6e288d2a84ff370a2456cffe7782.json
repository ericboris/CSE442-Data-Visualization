{"ast":null,"code":"const hash = {\n  title: 'Hash',\n  body: `Before we can talk about blockchains, we have to understand what a hash function is since hashing serves as the cryptographic foundation upon which blockchains function. Simply put, a hash is like a fingerprint - it uniquely identifies some data. More precisely, a hash function is a deterministic, one-way mathematical function that maps arbitrarily sized inputs to fixed sized outputs.\n\nYikes! Let's explain those terms.\n\nHashing is one way because it's fast and easy to compute the hash of some data, but it's practically impossible to figure out the data that produced a given hash. Hashing produces fixed sized outputs from arbitrary sized inputs. I.e. regardless of the amount of data that goes into a hash function, the resulting hash length will always be the same. And hashing is deterministic, the same data always produces the same hash.\n\nIn short, hashing privides easily identifiable, and impossible to reverse-engineer, fingerprints of data.`\n};\nconst block = {\n  title: 'Block',\n  body: `We now turn to the basic building block of any blockchain - a block. It's similar to the previous hash except there's an added Nonce field and a Mine button.\n\nWe can still change any of the fields as we like and the hash will change since the hash is computed using a combination of the Block, Nonce, and Data fields. However, the block won't be signed.\n\nWhat's a signed block? A signed block, in this case, is one where the hash that starts with 4 leading zeros.\n\nThat's where mining comes in. Mining is the task of finding a nonce such that when it's hashed with block number and data the hash starts with 4 zeros. When such a nonce is found and the hash starts with 4 zeros we say that block is signed.\n\nNote, the choice of 4 leading zeros is arbitrary and is used here for demonstration purposes only. The point is that finding a nonce that satisfies a hash constraint takes is computationally effortful.\n\nThe significance of mining a block is that it takes time to do but any attempts to change the state of a mined block can be instantly identified making it computationally expensive to change.\n\nPlay with the block component to get a feel for how any changes affect the hash and how mining changes the hash and the nonce.`\n};\nconst blockchain = {\n  title: 'Blockchain',\n  body: `Now we're ready to talk about a blockchain.\n\n        I addition to having multiple blocks now, you'll notice that we've added a \"previous hash\" field which references the hash of the previous block.\n\n        Suppose all the blocks are signed, but now we want to alter some field in the middle block, you'll see that doing so not only breaks the block with the changed field, it breaks every block in the\nchain as well! So by incorporating the previous block's hash in the computation for the following block we've connected each block in a chain.\n\n        This is important because if we wanted to manipulate the history of the blockchain we have to re-mine, not only the altered block but every block that follows which makes the blockchain tamper resistant and, in fact, more resistant to change the further back we go. This is one of the features that makes blockchains so important, anyone can access it but no one can reasonably edit it's history.`\n};\nconst distributed = {\n  title: 'Distributed',\n  body: ``\n};\nconst conclusion = {\n  title: 'Conclusion',\n  body: `THIS IS THE CONCLUSION BODY`\n};\nexport { hash, block, blockchain, distributed, conclusion };","map":{"version":3,"sources":["/Users/ericboris/Developer/CSE442/a4/src/descriptions/descriptions.js"],"names":["hash","title","body","block","blockchain","distributed","conclusion"],"mappings":"AAAA,MAAMA,IAAI,GAAG;AACTC,EAAAA,KAAK,EAAE,MADE;AAETC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AATa,CAAb;AAYA,MAAMC,KAAK,GAAG;AACVF,EAAAA,KAAK,EAAE,OADG;AAEVC,EAAAA,IAAI,EACP;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfc,CAAd;AAkBA,MAAME,UAAU,GAAG;AACfH,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EACC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AAVmB,CAAnB;AAaA,MAAMG,WAAW,GAAG;AAChBJ,EAAAA,KAAK,EAAE,aADS;AAEhBC,EAAAA,IAAI,EAAG;AAFS,CAApB;AAKA,MAAMI,UAAU,GAAG;AACfL,EAAAA,KAAK,EAAE,YADQ;AAEfC,EAAAA,IAAI,EAAG;AAFQ,CAAnB;AAKA,SAASF,IAAT,EAAeG,KAAf,EAAsBC,UAAtB,EAAkCC,WAAlC,EAA+CC,UAA/C","sourcesContent":["const hash = {\n    title: 'Hash',\n    body:\n`Before we can talk about blockchains, we have to understand what a hash function is since hashing serves as the cryptographic foundation upon which blockchains function. Simply put, a hash is like a fingerprint - it uniquely identifies some data. More precisely, a hash function is a deterministic, one-way mathematical function that maps arbitrarily sized inputs to fixed sized outputs.\n\nYikes! Let's explain those terms.\n\nHashing is one way because it's fast and easy to compute the hash of some data, but it's practically impossible to figure out the data that produced a given hash. Hashing produces fixed sized outputs from arbitrary sized inputs. I.e. regardless of the amount of data that goes into a hash function, the resulting hash length will always be the same. And hashing is deterministic, the same data always produces the same hash.\n\nIn short, hashing privides easily identifiable, and impossible to reverse-engineer, fingerprints of data.`\n};\n\nconst block = {\n    title: 'Block',\n    body:\n`We now turn to the basic building block of any blockchain - a block. It's similar to the previous hash except there's an added Nonce field and a Mine button.\n\nWe can still change any of the fields as we like and the hash will change since the hash is computed using a combination of the Block, Nonce, and Data fields. However, the block won't be signed.\n\nWhat's a signed block? A signed block, in this case, is one where the hash that starts with 4 leading zeros.\n\nThat's where mining comes in. Mining is the task of finding a nonce such that when it's hashed with block number and data the hash starts with 4 zeros. When such a nonce is found and the hash starts with 4 zeros we say that block is signed.\n\nNote, the choice of 4 leading zeros is arbitrary and is used here for demonstration purposes only. The point is that finding a nonce that satisfies a hash constraint takes is computationally effortful.\n\nThe significance of mining a block is that it takes time to do but any attempts to change the state of a mined block can be instantly identified making it computationally expensive to change.\n\nPlay with the block component to get a feel for how any changes affect the hash and how mining changes the hash and the nonce.`\n};\n\nconst blockchain = {\n    title: 'Blockchain',\n    body:\n        `Now we're ready to talk about a blockchain.\n\n        I addition to having multiple blocks now, you'll notice that we've added a \"previous hash\" field which references the hash of the previous block.\n\n        Suppose all the blocks are signed, but now we want to alter some field in the middle block, you'll see that doing so not only breaks the block with the changed field, it breaks every block in the\nchain as well! So by incorporating the previous block's hash in the computation for the following block we've connected each block in a chain.\n\n        This is important because if we wanted to manipulate the history of the blockchain we have to re-mine, not only the altered block but every block that follows which makes the blockchain tamper resistant and, in fact, more resistant to change the further back we go. This is one of the features that makes blockchains so important, anyone can access it but no one can reasonably edit it's history.`\n};\n\nconst distributed = {\n    title: 'Distributed',\n    body: ``\n}\n\nconst conclusion = {\n    title: 'Conclusion',\n    body: `THIS IS THE CONCLUSION BODY`\n}\n\nexport { hash, block, blockchain, distributed, conclusion }\n"]},"metadata":{},"sourceType":"module"}