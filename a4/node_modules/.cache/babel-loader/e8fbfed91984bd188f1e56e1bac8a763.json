{"ast":null,"code":"const hash = {\n  title: 'Hash',\n  body: `Before we can discuss blockchains we have to understand what a hash function is. A hash function is a determinisic, one-way mathematical function that maps arbitrarily sized data (input) to a fix\n                                                                                  \n        There are three key features here.                                        \n        1. One-Way. It's functionally impossible, even knowing the output, to reverse engineer the input. \n        2. Arbitrary sized input to fixed size output. Whether the input is an empty string or the text every book ever written, the output array will be the same size. In this case, using SHA256, the out\n        3. Deterministic. The same input always produces the same output.         \n                                                                                  \n        On a blockchain, like Bitcoin for example, hashing is used to verify that a certain amount of computation work has been conducted.`\n};\nconst block = {\n  title: 'Block',\n  body: `We now have the basic building block of a blockchain - a block. It's similar to the previous hash except there's an added Nonce field and a Mine button. \n                                                                                  \n        We can still change any of the fields as we like and the hash will change since the hash is computed using a combination of the Block, Nonce, and Data fields. However, the block won't be signed. \n                                                                                  \n        What's a signed block? A signed block, in this case, is one where the hash that starts with 4 leading zeros.\n                                                                                  \n        That's where mining comes in. Mining is the task of finding a nonce such that when it's hashed with block number and data the hash starts with 4 zeros. When such a nonce is found and the hash star\n                                                                                  \n        Note, the choice of 4 leading zeros is arbitrary and is used here for demonstration purposes only. The point is that finding a nonce that satisfies a hash constraint takes is computationally effor\n                                                                                  \n        The significance of mining a block is that it takes time to do but any attempts to change the state of a mined block can be instantly identified making it computationally expensive to change.\n                                                                                  \n        Play with the block component to get a feel for how any changes affect the hash and how mining changes the hash and the nonce.`\n};\nexport { hash, block };","map":{"version":3,"sources":["/Users/ericboris/Developer/CSE442/a4/src/descriptions/descriptions.js"],"names":["hash","title","body","block"],"mappings":"AAAA,MAAMA,IAAI,GAAG;AACTC,EAAAA,KAAK,EAAE,MADE;AAETC,EAAAA,IAAI,EACC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AAVa,CAAb;AAaA,MAAMC,KAAK,GAAG;AACVF,EAAAA,KAAK,EAAE,OADG;AAEVC,EAAAA,IAAI,EACC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfc,CAAd;AAkBA,SAASF,IAAT,EAAeG,KAAf","sourcesContent":["const hash = {                                                         \n    title: 'Hash',                                                                \n    body:                                                                         \n        `Before we can discuss blockchains we have to understand what a hash function is. A hash function is a determinisic, one-way mathematical function that maps arbitrarily sized data (input) to a fix\n                                                                                  \n        There are three key features here.                                        \n        1. One-Way. It's functionally impossible, even knowing the output, to reverse engineer the input. \n        2. Arbitrary sized input to fixed size output. Whether the input is an empty string or the text every book ever written, the output array will be the same size. In this case, using SHA256, the out\n        3. Deterministic. The same input always produces the same output.         \n                                                                                  \n        On a blockchain, like Bitcoin for example, hashing is used to verify that a certain amount of computation work has been conducted.`\n};  \n\nconst block = {                                                        \n    title: 'Block',                                                               \n    body:                                                                         \n        `We now have the basic building block of a blockchain - a block. It's similar to the previous hash except there's an added Nonce field and a Mine button. \n                                                                                  \n        We can still change any of the fields as we like and the hash will change since the hash is computed using a combination of the Block, Nonce, and Data fields. However, the block won't be signed. \n                                                                                  \n        What's a signed block? A signed block, in this case, is one where the hash that starts with 4 leading zeros.\n                                                                                  \n        That's where mining comes in. Mining is the task of finding a nonce such that when it's hashed with block number and data the hash starts with 4 zeros. When such a nonce is found and the hash star\n                                                                                  \n        Note, the choice of 4 leading zeros is arbitrary and is used here for demonstration purposes only. The point is that finding a nonce that satisfies a hash constraint takes is computationally effor\n                                                                                  \n        The significance of mining a block is that it takes time to do but any attempts to change the state of a mined block can be instantly identified making it computationally expensive to change.\n                                                                                  \n        Play with the block component to get a feel for how any changes affect the hash and how mining changes the hash and the nonce.`\n};                                                                                \n\nexport { hash, block }\n"]},"metadata":{},"sourceType":"module"}